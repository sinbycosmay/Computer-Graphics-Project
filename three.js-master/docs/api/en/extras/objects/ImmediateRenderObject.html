<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		[page:Object3D] &rarr;

		<h1>[name]</h1>

		<p class="desc">
			This experimental class provides a fast code path for rendering meshes with frequently updated
			geometry data. When the renderer encounters an instance of [name], it only takes care about
			the most primitive rendering operations (e.g. binding vertex attributes, determining correct shader
			program or perfoming the actual draw call). Features like view frustum culling, wireframe rendering
			or using multiple materials are not supported. Besides [name] can only be used to render triangles.
		</p>

		<p class="desc">
			[name] does not work with instances of [page:BufferGeometry]. The
			raw geometry data have to be maintained as properties of the [name].
		</p>

		<p class="desc">
			Using [name] makes only sense if you are updating your geometry data per frame. You can then
			benefit of a faster code path compared to the default mesh redering logic.
		</p>

		<h2>Examples</h2>
		<p>
			[example:webgl_marchingcubes Marching Cubes]
		</p>

		<h2>Constructor</h2>


		<h3>[name]( [param:Material material] )</h3>
		<p>
		[page:Material material] â€” The material of the [name].
		</p>

		<h2>Properties</h2>
		<p>See the base [page:Object3D] class for common properties.</p>

		<h3>[property:Boolean material]</h3>
		<p>
			The material of the [name]. Assigning multiple materials is not supported.
		</p>

		<h3>[property:Boolean hasPositions]</h3>
		<p>
			Whether position data are defined or not. Default is *false*.
		</p>

		<h3>[property:Boolean hasNormals]</h3>
		<p>
			Whether normal data are defined or not. Default is *false*.
		</p>

		<h3>[property:Boolean hasColors]</h3>
		<p>
			Whether color data are defined or not. Default is *false*.
		</p>

		<h3>[property:Boolean hasUvs]</h3>
		<p>
			Whether texture coordinates are defined or not. Default is *false*.
		</p>

		<h3>[property:Float32Array positionArray]</h3>
		<p>
			The buffer holding position data. Default is *null*.
		</p>

		<h3>[property:Float32Array normalArray]</h3>
		<p>
			The buffer holding normal data. Default is *null*.
		</p>

		<h3>[property:Float32Array colorArray]</h3>
		<p>
			The buffer holding color data. Default is *null*.
		</p>

		<h3>[property:Float32Array uvArray]</h3>
		<p>
			The buffer holding texture coordinates. Default is *null*.
		</p>

		<h3>[property:Integer count]</h3>
		<p>
			The number of primitives to be rendered. Default is *0*.
			This property will be set to *0* after each rendering so you usually
			set it in the implementatio of [page:.render]().
		</p>

		<h2>Methods</h2>

		<p>See the base [page:Object3D] class for common methods.</p>

		<h3>[method:null render]([param:Function renderCallback])</h3>
		<p>
		renderCallback -- A function to render the generated geometry data.
		</p>
		<p>
		This method needs to be implemented by the deriving class of [name]. You normally want to implement the
		vertex buffer update logic and execute *renderCallback* at the end of your implementation.
		</p>

		<h2>Source</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
